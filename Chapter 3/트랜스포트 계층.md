# 트랜스포트 계층

# Chapter 3. 트랜스포트 계층

# 3.1 트랜스포트 계층 서비스 및 개요

트랜스포트 계층 프로토콜은 각기 다른 호스트에서 동작하는 애플리케이션 프로세스 간의 논리적 통신(logical communication)을 제공한다.

= 애플리케이션의 관점에서 보면, 프로세스들이 동작하는 호스트들이 직접 연결된 것처럼 보인다.

트랜스포트 계층 프로토콜은 네트워크 라우터가 아닌 종단 시스템에서 구현된다.

1. 송신 측의 트랜스포트 계층은 송신 애플리케이션 프로세스로부터 수신한 메시지를 트랜스포트 계층 패킷으로 변환한다.
    
    (이는 트랜스포트 계층 세그먼트(segment)라고 부른다. : L4-PDU)
    
    - PDU(Protocol Data Unit, 프로토콜 데이터 단위)
        - L4-PDU (Transport Layer PDU) : L4(4계층, 전송 계층)
            - TCP 프로토콜을 사용할 때는 세그먼트(Segment)
            - UDP 프로토콜을 사용할 때는 데이터그램(Datagram)
    1. 애플리케이션 메시지를 작은 조각으로 분할한다.
    2. 각각의 조각에 트랜스포트 계층 헤더를 추가한다.
2. 트랜스포트 계층은 송신 종단 시스템에 있는 네트워크 계층으로 세그먼트를 전달한다.
    - 세그먼트는 네트워크 계층 패킷(데이터그램(datagram) : L3-PDU) 안에 캡슐화되어(encapsulate) 목적지로 전달된다.
        - L3-PDU(3계층, 네트워크 계층)
            - TCP, UDP 통틀어 : 패킷 = ip 데이터그램
    - 네트워크 라우터는 오로지 데이터그램의 네트워크 계층 필드에 대해 동작한다.
        
        즉, 데이터그램 안에 캡슐화된 트랜스포트 계층 세그먼트의 필드를 검사하지 않는다.
        
3. 수신 측에서 네트워크 계층은 데이터그램으로부터 트랜스포트 계층 세그먼트를 추출하고 트랜스포트 계층으로 세그먼트를 보낸다.
4. 트랜스포트 계층은 수신 애플리케이션에서 세그먼트 내부의 데이터를 이용할 수 있도록 수신된 세그먼트를 처리한다.

네트워크 애플리케이션에서는 하나 이상의 트랜스포트 계층 프로토콜을 사용할 수 있다.

ex) 인터넷 : TDP, UDP라는 두 가지 프로토콜을 가지고 있다.

## 3.1.1 트랜스포트 계층과 네트워크 계층 사이의 관계

트랜스포트 계층 프로토콜은 각기 다른 호스트에서 동작하는 프로세스들 사이의 논리적 통신을 제공한다.

네트워크 계층 프로토콜은 호스트들 사이의 논리적 통신을 제공한다.

- 트랜스포트 계층 프로토콜은 종단 시스템에 존재하며, 애플리케이션 프로세스에서 네트워크 계층 사이에서 메시지를 운반하는 역할을 한다.
- 메시지가 네트워크 계층 내부에서 어떻게 이동하는지는 언급하지 않는다.
    - 즉, Application을 다루는(작성하거나 run 하는) 입장에서는 앞으로 이루어질 physical connection을 염려하지 않아도 된다.
1. 트랜스포트 계층이 제공할 수 있는 서비스는 하위 네트워크 계층 프로토콜의 서비스 모델에 의해 제약받는다.
    
    네트워크 계층 프로토콜이 호스트 사이에서 전송되는 트랜스포트 계층 세그먼트에 대한 지연 보장이나 대역폭 보장을 제공할 수 없다면,
    
    트랜스포트 계층 프로토콜은 프로세스끼리 전송하는 메시지에 대한 지연 보장이나 대역폭 보장을 제공할 수 없다.
    
2. 하위 네트워크 프로토콜이 상응하는 서비스를 제공하지 못할 때도, 특정 서비스는 트랜스포트 프로토콜에 의해 제공될 수 있다.
    
    하위 네트워크 프로토콜이 비신뢰적일 때, 트랜스포트 계층이 애플리케이션에게 신뢰적인 데이터 전송 서비스를 제공할 수 있다.
    
    (비신뢰적이다 = 패킷을 분실하거나, 손상시키거나, 복사본을 만든다)
    

## 3.1.2 인터넷 트랜스포트 계층의 개요

TCP : Transmission Control Protocol

- 신뢰적이고 연결지향형 서비스를 제공한다. (reliable data transfer)
- 혼잡 제어(congestion control) : 혼잡한 네트워크 링크에서 각 TCP 연결이 링크의 대역폭을 공평하게 공유하여 통과하도록 해준다.

UDP : User Datagram Protocol

- 비신뢰적이고 비연결형인 서비스를 제공한다.
- UDP 트랜스포트 프로토콜을 사용하는 애플리케이션은 허용이 되는 한, 그것이 만족하는 어떤 속도로든 전송할 수 있다.

### 세그먼트와 데이터그램

- 세그먼트(segment) : 트랜스포트 계층 패킷을 일컫는 말
- TCP에 대한 패킷을 세그먼트(segment), UDP에 대한 패킷을 데이터그램(datagram)이라는 용어로 나타내기도 한다.

이 책에서는 TCP와 UDP 패킷을 모두 세그먼트라고 지칭, 네트워크 계층 패킷에 대해서는 데이터그램이라는 용어를 사용한다.

### 인터넷 프로토콜(Internet Protocol, IP)

인터넷의 네트워크 계층 프로토콜

IP 서비스 모델은 호스트들 간에 논리적 통신을 제공하는 최선형 전달 서비스(best-effort delivery service)

즉, IP가 통신하는 호스트들 간에 세그먼트를 전달하기 위해 최대한 노력하지만, 어떤 보장도 하지 않는다.

- 세그먼트의 전달 보장 X
- 순서 보장 X
- 내부 데이터의 무결성(integrity) 보장 X

→ IP는 비신뢰적인 서비스(unreliable service)이다.

각 호스트는 적어도 하나의 IP 주소를 갖고 있다.

### UDP와 TCP의 서비스 모델

**트랜스포트 계층 다중화(transport-layer mulitplexing)와 역다중화(demultiplexing)**

‘호스트 대 호스트 전달’ → ‘프로세스 대 프로세스 전달’

종단 시스템 사이의 IP 전달 서비스를 / 종단 시스템에서 동작하는 두 프로세스 간의 전달 서비스로 확장한다.

헤더에 오류 검출 필드를 포함하여 무결성 검사를 제공한다.

# **3.2 다중화와 역다중화**

### 트랜스포트 계층 다중화(multiplexing)와 역다중화(demultiplexing)

네트워크 계층이 제공하는 호스트 대 호스트 전달 서비스에서

호스트에서 동작하는 애플리케이션에 대한 프로세스 대 프로세스 전달 서비스로 확장하는 과정

1. 목적지 호스트에서의 트랜스포트 계층은 바로 아래의 네트워크 계층으로부터 세그먼트를 수신한다.
    
    트랜스포트 계층은 호스트에서 동작하는 해당 애플리케이션 프로세스에게 이 세그먼트의 데이터를 전달하는 의무를 가진다.
    
2. 트랜스포트 계층은 세그먼트(데이터)를 중간 매개자인 소켓(socket)에게 전달한다.
    - 프로세스는 네트워크 애플리케이션의 한 부분으로서 소켓을 가지고 있다.
    - 이는 네트워크에서 프로세스로, 한 프로세스로부터 네트워크로 데이터를 전달하는 출입구 역할을 한다.
    - 각각의 소켓은 하나의 유일한 식별자, 포트 번호(port number)를 가진다.

각각의 트랜스포트 계층 세그먼트는 세그먼트에 필드 집합을 가지고 있으며,

트랜스포트 계층은 수신 소켓을 식별하기 위해 이러한 필드를 검사한 후 해당 소켓으로 보낸다.

- 역다중화(demultiplexing)

트랜스포트 계층 세그먼트의 데이터를 올바른 소켓으로 전달하는 작업을 말한다.

- 다중화(multiplexing)
1. 출발지 호스트에서 소켓으로 부터 데이터를 모으고,
2. 이에 대한 세그먼트를 생성하기 위해 각 데이터에 헤더 정보로 캡슐화(encapsulation) 한다.
3. 그 세그먼트들을 네트워크 계층으로 전달한다.

### 트랜스포트 계층 다중화의 두 가지 요구사항

1. 소켓은 유일한 식별자를 갖는다. (= 포트 번호)
2. 각 세그먼트는 세그먼트가 전달될 적절한 소켓을 가리키는 특별한 필드를 갖는다.
    - 출발지 포트 번호 필드(source port number field)
    - 목적지 포트 번호 필드(destination port number field)

### 역다중화 서비스의 순서

1. 호스트의 각 소켓은 포트 번호를 할당받는다.
2. 세그먼트가 호스트에 도착하면,
    1. 트랜스포트 계층은 세그먼트 안의 목적지 포트 번호를 검사하고,
    2. 그에 상응하는 소켓으로 세그먼트를 보낸다.
3. 세그먼트의 데이터는 소켓을 통해 해당되는 프로세스로 전달된다.

이는 UDP의 기본적인 동작 방식과 같다.

### 비연결형 다중화와 역다중화

UDP 소켓은 목적지 IP 주소와 목적지 포트 번호로 구성된 두 요소로 된 집합에 의해 식별된다.

따라서 만약 2개의 UDP 세그먼트가 같은 목적지 IP 주소와 목적지 포트 번호를 가진다면,

이 2개의 세그먼트는 같은 목적지 소켓을 통해 같은 프로세스로 향할 것이다.

그렇다면 출발지 포트 번호는 무슨 목적으로 사용되는가?

출발지 포트 번호는 ’회신 주소’의 한 부분으로 사용된다.

B가 A에게로 세그먼트를 보내기를 원할 때

B에서 A로 가는 세그먼트의 목적지 포트 번호는 A로부터 B로 가는 세그먼트의 출발지 포트 번호로부터 가져온다.

### 연결지향형 다중화와 역다중화

TCP 소켓

TCP 소켓은 4개 요소의 집합(four-tuple)에 의해 식별된다.

- 출발지 IP 주소
- 출발지 포트 번호
- 목적지 IP 주소
- 목적지 포트 번호

특히, 다른 출발지 IP 주소 또는 다른 출발지 포트 번호를 가지고 도착하는 2개의 TCP 세그먼트는 2개의 다른 소켓으로 향하게 된다.

(초기 연결 설정 요청을 전달하는 TCP는 제외)

### TCP 연결 설정

1. TCP 서버 애플리케이션은 환영(welcome) 소켓을 갖고 있다.
    
    이 소켓은 포트 번호 12000을 가진 TCP 클라이언트로부터 연결 설정 요청을 기다린다.
    
2. TCP 클라이언트는 소켓을 생성하고, 연결 설정 요청 세그먼트를 보낸다.SYN
    - 연결 설정 요청은 목적지 포트 번호 12000과 TCP 헤더에 설정된 특별한 연결 설정 비트(3.5절에서 설명)를 가진 TCP 세그먼트를 통해 보내진다.
    - 이 세그먼트는 출발지 포트 번호를 포함하는데, 이것은 클라이언트가 선택한 번호이다.
3. 서버 프로세스로 동작하는 컴퓨터의 호스트 운영체제가 목적지 포트 12000을 포함하는 연결 요청 세그먼트를 수신하면,
    
    이 세그먼트를 포트 번호 12000으로 연결 수락을 기다리는 서버 프로세스로 보낸다. SYN+ACK
    
4. 서버는 연결 요청 세그먼트의 4개 요소의 집합에 주목한다. ACK
    
    서버 호스트는 동시에 존재하는 많은 TCP 소켓을 지원할 수 있다.
    
    - 새롭게 생성된 연결 소켓은 4개 요소의 집합의 네 가지 값에 의해 식별된다.
    - 따라서 그다음에 도착하는 세그먼트의 출발지 포트, 출발지 IP 주소, 목적지 포트, 목적지 IP 주소가 전부 일치하면, 그 세그먼트는 이 소켓으로 역다중화될 것이다.

### 웹 서버와 TCP

서버는 각기 다른 클라이언트가 보낸 세그먼트를 출발지 IP 주소와 출발지 포트 번호로 구별한다.

같은 웹 서버 애플리케이션과 통신하기 위해 같은 목적지 포트 번호(80)를 이용하는 두 클라이언트에 대한 예시를 보자.

- 호스트 C가 서버 B로 2개의 HTTP 세션을 시작
- 호스트 A가 서버 B로 하나의 HTTP 세션을 시작

호스트 A, 호스트 C, 서버 B는 각자 유일한 IP 주소인 A, C, B를 각각 가지고 있다.

- 호스트 C는 2개의 출발지 포트 번호(26145, 7532)를 자신의 HTTP 연결에 할당한다.
- 호스트 A는 호스트 C와 독립적으로 출발지 포트 번호를 선택하므로, 이것 또한 HTTP 연결에 출발지 포트로 26145를 할당할 수 있다.

이렇게 하더라도, 2개의 연결은 다른 출발지 IP 주소를 가지기 때문에 서버 B는 여전히 올바르게 역다중화할 수 있다.

웹 서버는 각각의 연결에 따라서 새로운 프로세스를 만든다.

이들 프로세스는 각자 연결 소켓을 가지며, 이 연결 소켓을 통해 HTTP 요청을 수신하고, HTTP 응답을 전송한다.

그러나 연결 소켓과 프로세스 사이에 항상 일대일 대응이 이루어지는 것이 아니다.

- 오늘날의 많은 고성능 웹 서버는 하나의 프로세스만 사용한다.
- 각각의 새로운 클라이언트 연결을 위해 새로운 연결 소켓과 함께 새로운 스레드(thread)를 생성한다.

### Persistent & Non-persistent HTTP

지속적인(persistent) HTTP

지속적인 연결의 존속 기간에 클라이언트와 서버는 같은 서버 소켓을 통해 HTTP 메시지를 교환한다.

비지속적인(non-persistent) HTTP

모든 요청/응답마다 새로운 TCP 연결이 생성되고 종료된다.

---

# 3.3 비연결형 트랜스포트: UDP

UDP로도 신뢰적인 데이터 전송이 가능하고, 혼잡제어가 가능하다.

구글에서 제공하는 QUIC(Quick UDP Internet Connection) 같은 경우 UDP를 사용하고도 애플리케이션 계층 프로토콜의 안정성을 구현했다.

내가 직접 UDP로 통신하는 웹 서버를 만들자! -> 는 완벽한 HTTP/3 QUIC를 구현해서 프로토콜 등록하는게 아니면 보안적으로 막혀있다. (HTTP는 사용자 정의 프로토콜을 막아두었기 때문에)

## 3.3.1 UDP 세그먼트 구조

UDP 헤더는 2바이트씩 구성된 4개의 필드만을 가진다.(TCP는 20바이트를 가진다)

출발지 포트 번호, 목적지 포트 번호, 길이, 체크섬 (각 2바이트)

## 3.3.2 UDP 체크섬

많은 링크 계층 프로토콜이 오류 검사를 제공하는데도 불구하고, UDP에서 체크섬을 제공하는 이유는 출발지와 목적지 사이의 모든 링크가 오류 검사를 제공할거라는 보장이 없기 때문이다.

시스템 설계에서 유명한 종단과 종단의 원칙(end-end principle)의 예로, ’하위 레벨에 있는 기능들은 상위레벨에서 이를 제공하는 비용과 비교했을 때 중복되거나 거의 가치가 없을 수 있다’는 것

```
참고

UDP에서 체크섬을 검사하는것은 링크계층(2계층)이 아닌, 트랜스포트 계층(4계층)에서 검사한다.

하지만 UDP는 검사해서 손상된 세그먼트가 있어도, 그냥 버리거나 그냥 어플리케이션에게 넘겨준다.
```

# 3.4 신뢰적인 데이터 전송의 원리

신뢰적인 데이터 전송(RDT, reliable data transfer)
신뢰적인 채널에서는 전송된 데이터가 손상되거나 손실되지 않으며,
모든 데이터는 전송된 순서 그대로 전달된다.

## 3.4.1 신뢰적인 데이터 전송 프로토콜의 구축

가정 : 모든 데이터는 순서대로 도착함.

여기서는 단방향 데이터 전송의 경우만 구현하며 신뢰적인 양뱡향(전이중) 데이터 전송은 개념은 어렵지 않으나 설명하기 어려우므로 생략

아래서 기술하는 rdt 1.0 -> 3.0의 과정은 직접 만들어보는 과정임.

### 완벽하게 신뢰적인 채널상에서의 신뢰적인 데이터 전송 : rdt1.0

가정 1. 모든 데이터의 송신, 수신이 신뢰 가능할 경우

가정 2. 수신자는 송신자가 데이터를 송신하자마자 데이터를 수신할 수 있다.

어떠한 오류 검증 및 재전송 과정도 이루어지지 않음

수신자가 송신자에게 천천히 보내라는 요청도 필요없음.

### 비트 오류가 있는 채널상에서의 신뢰적 데이터 전송 : rdt2.0

현상 : 데이터에 비트 오류(비트가 바뀌는 현상)이 발생할 수 있음

수신자가 송신자에게 보내는 제어 메시지

- 긍정 확인응답(positive acknowledgment, ACK) : 수신자가 데이터를 잘 받았음을 알려주는 메시지
- 부정 확인응답(negative acknowledgment, NAK) : 수신자가 데이터를 잘 받지 못했음을 알려주는 메시지

컴퓨터 네트워크 설정에서 위와 같이 재전송을 기반으로 하는 신뢰적인 데이터 전송 트로토콜은 자동 재전송 요구(Automatic Repeat reQuest, ARQ) 프로토콜로 알려져 있다.

비트 오류를 처리하기 위해 세 가지 부가 프로토콜 기능이 ARQ 프로토콜에 요구된다.

1. 오류 검출 : 수신자가 수신한 데이터에 오류가 있는지 확인할 수 있어야 한다. (6장에서 기술)
2. 수신자 피드백 : ACK, NAK를 송신자에게 보내야 한다.
3. 재전송 : 수신자에서 오류를 가지고 수신된 패킷은 송신자에서 재전송되어야 한다.

송신자가 ACK, NAK를 수신하지 못하면 다른 데이터를 전달받을 수 없다.

이러한 행동을 전송 후 대기(stop-and-wait) 프로토콜로 알려져 있다.

결함 : ACK, NAK 패킷이 손상될 수 있음을 고려하지 않음.

해결방법

1. ACK, NAK 패킷에 대한 ACK, NAK 메시지를 만든다.
    
    결함 : 무한으로 NAK 메시지를 보내는 상황이 발생할 수 있다.
    
2. 송신자가 검출뿐 아니라 비트오류로 부터 회복할 수 있도록 충분한 체크섬 비트들을 추가하는 방법
    
    결함 : ACK, NAK 패킷이 손실되는 상황을 고려하지 않음.
    
3. 송신자가 왜곡된 ACK, NAK 패킷을 수신했을때 현재 데이터 패킷을 그냥 보내기
    
    결함 1 : 이 방식은 중복 패킷이 발생된다.
    
    결함 2 : 마지막으로 전송된 ACK, NAK패킷이 송신자에게 올바르게 도착했는지를 알 수 없다.
    
    결과 : 새로운 데이터인지, 재전송 데이터인지를 알 수 없다.
    

### 위 결함을 해결하는 방법 rdt 2.1

TCP를 포함한 모든 현존하는 데이터 전송 프로토콜에 채택된 방법은 송신자가 순서 번호(sequence number)를 데이터 패킷에 새로운 필드로 추가하는 것

가정 1. 패킷이 손실되어지지 않는 채널임

따라서 재전송인지 확인하기 위해 수신자는 순서번호로 알 수 있다.

### NAK 패킷을 제거한 rdt 2.2

오류가 있더라도 NAK를 보내지 않고, 마지막으로 정상 수신한 패킷의 ACK 번호를 보낸다.

프로토콜이 간단해짐.

### 비트 오류와 손실 있는 채널상에서의 신뢰적인 데이터 전송 : rdt3.0

현상 : 패킷이 유실될 수 있음.

결과 : 전송 후 대기(stop-and-wait) 때문에 무한 대기에 빠지게 됨

timeout 시간을 설정하여야 함.

결함 1 : timeout 시간이 너무 짧으면, 패킷이 도착했는데도 재전송을 하지만, 위의 순서 번호로 대처가 가능하다.

결함 2 : timeout 시간이 너무 길면 오래 지연된다.

ACK가 늦게 오거나 타임아웃이 발생해 같은 패킷이 여러 번 도착해도,

순서 번호가 같으면 재전송으로 간주하고, 다르면 새로운 데이터로 인식

패킷의 순서 번호가 0과 1이 번갈아 이루어지므로 얼터네이팅 비트(alternating bit) 프로토콜이라고도 불린다.

와 ! 신뢰적으로 동작하는 데이터 전송 프로토콜이 완성되었다!

## 3.4.2 파이프라이닝된 신뢰적인 데이터 전송 프로토콜

현상 : rdt3.0은 전송 후 대기(stop-and-wait) 프로토콜이므로, 송신자는 ACK를 기다리는 동안 아무것도 하지 못한다.

이를 해결하기 위해 송신자가 여러 개의 패킷을 연속적으로 전송할 수 있도록 하는 파이프라이닝(pipelining) 기술을 사용한다.

조건 1. 순서번호는 유일한 순서 번호를 가져야 하므로 범위를 확장해야 한다.

조건 2. 송신 측과 수신 측은 패킷 하나 이상을 버퍼링해야한다.

아니면 처리속도를 따라가지 못해 패킷이 손실될 수 있다.

순서 번호의 범위와 버퍼링 조건은 데이터 전송 프로토콜에서 손실, 손상, 지연 패킷을 응답하는 방법에 따라 다르다.

파이프라인의 오류 회복의 두가지 접근 방법은

- Go-Back-N (GBN) : N부터 반복
- Selective Repeat (SR) : 선택적 반복

으로 나뉜다.

## 3.4.3. GBN(Go-Back-N)

송신자는 확인 응답을 기다리지 않고 여러 패킷을 전송가능할 때 사용 가능하다.

그러나 파이프라인에서 확인응답이 안 된 패킷의 최대 허용수인 N을 초과할 수 없다.

https://www.tkn.tu-berlin.de/teaching/rn/animations/gbn_sr/

N == 윈도 크기(window size)라고 부르며, GBN 프로토콜은 슬라이딩 윈도(sliding window) 프로토콜이라고도 불린다.

N을 무한대로 놓지 않는 이유는 흐름 제어와 혼잡 제어에서 설명한다.

여기서 수신자는 순서에 맞지 않는 패킷을 다 버리고, 현재 몇번 패킷까지 수신했는지를 관리하며, 이를 ACK로 송신자에게 알려준다.

송신자는 타임아웃이 발생하면 ACK를 기다리지 않고, N개의 패킷을 모두 재전송한다.

이는 수신자의 버퍼링을 고려하기 위함이다.

하지만 그 단점으로 많은 올바르게 수신된 패킷이 버려지고, 많은 재전송이 발생할 수 있다.

## 3.4.4 SR(Selective Repeat)

GBN에서 윈도 크기와 대역폭 지연의 곱이 클 경우, 많은 패킷이 파이프라인에 있을 수 있다.

이 때 GBN은 많은 패킷을 재전송 하므로 성능저하가 발생한다.

수신자는 순서가 맞지 않아도 일단 버퍼에 저장, 이후 부족한 패킷이 도착하면 순서대로 상위 계층에 전달 합니다.

각 패킷마다 타이머를 두고, 타임아웃 시 해당 패킷만 재전송

윈도우 크기가 시퀀스 번호 공간의 절반 이하로 제한되어야 오해(중복 인식)를 막을 수 있음

0 1 2 3 4 0 1 2 와 같은 경우에서 0, 1, 2가 중복으로 수신될 수 있기 때문

# 3.5 연결지향형 트랜스포트 : TCP

UDP와 달리 TCP는 신뢰적인 트랜스포트 프로토콜이므로, 오류 검출, 재전송, 누적 확인응답, 타이머, 순서 번호 등의 헤더가 있다는 걸 알 수 있음.

## 3.5.1 TCP 연결

TCP는 연결 지향형(connection-oriented) 프로토콜이므로 데이터 전송을 보장하는 파라미터들을 설정하기 위해 사전 세그먼트를 보내야 한다.

TCP 연결은 사실 회선 교환 네트워크에서와 같은 종단 간의 TDM(Time Division Multiplexing), FDM(Frequency Division Multiplexing)이 아니다.

TCP 프로토콜은 오직 종단 시스템에서만 동작하고, 중간의 네트워크 요소(라우터, 스위치)등 은 감지하지 못한다.

TCP 연결은 전이중 서비스(full-duplex service)를 제공하며, 항상 단일 송신자와 단일 수신자 사이의 점대점 연결(point-to-point connection)이다.

한 송신자가 여러 수신자에게 데이터를 전송하는 멀티캐스팅(multicasting)은 안된다!

세 방향 핸드셰이크(three-way handshake)를 통해 TCP 연결을 설정하고(자세한건 3장의 마지막에서 설명) 이 동안 송신 버퍼와 수신 버퍼를 할당한다.

TCP 명세서[RFC 793]에 따르면 TCP는 `자신이 편한대로 세그먼트의 데이터를 전송` 해야한다고 기술되어 있으며, 언제 버퍼된 데이터를 전송할지는 기술되어있지 않다.

세그먼트로 모아 담을 수 있는 최대 데이터의 양은 최대 세그먼트 크기(MSS, Maximum Segment Size)로 제한된다.

MSS는 일반적으로 로컬 송신 호스트에 의해 전송될 수 있는 가장 큰 링크 프레임의 길이(최대 전송 단위 MTU, Maximum Transmission Unit)에서 TCP세그먼트(IP 데이터그램 안에 캡슐화되었을 때)와 TCP/IP 헤더 길이(통상 40바이트)를 빼서 딱 맞도록 정한다.

## 3.5.2 TCP 세그먼트 구조

TCP 헤더는 일반적으로 20바이트의 길이를 가진다.

각 16비트 : 출발지와 목적지 포트 번호(source and destination port number)

16비트 : 체크섬 필드(checksum field)

32비트 : 순서 번호 필드(sequence number field)

32비트 : 확인응답 번호 필드(acknowledgement number field)

16비트 : 수신 윈도(receive window)

4비트 : 헤더 길이 필드(header length field)

옵션 필드(option field) : 선택적이고 가변적인 길이를 가진다.

- 송신자와 수신자가 최대 세그먼트 크기(MSS)를 협상하거나 고속 네트워크에서 사용하기 위한 윈도 확장 요소로 이용된다.

6비트 플래그 필드(flag field) :
* ACK 비트 : 확인응답 필드에 있는 값이 유용함을 가리키는 데 사용된다.

- RST, SYN, FIN 비트 : 연결 설정과 해제에 사용된다.
- PSH 비트 : 이 비트가 설정되었다면 이것은 수신자가 데이터를 상위 계층에 즉시 전달해야 함을 가리킨다.
- URG 비트
이 세그먼트에서 송신 측 상위 계층 개체가 ’긴급’으로 표시하는 데이터임을 가리킨다.
    
    이 긴급 데이터의 마지막 바이트의 위치는 16비트의 긴급 데이터 포인터 필드(urgent data pointer field)에 의해 가리켜진다.
    

### 순서 번호와 확인응답 번호

이 두 필드는 TCP의 신뢰적인 데이터 전송 서비스의 중대한 부분이다.

- 순서 번호
    - TCP는 데이터를 구조화되어 있지 않고 단지 순서대로 정렬되어 있는 바이트 스트림으로 본다.
    - 세그먼트에 대한 순서 번호는 세그먼트에 있는 첫 번째 바이트의 바이트 스트림 번호다.
    - 각각의 순서 번호는 적절한 TCP 세그먼트의 헤더 내부의 순서 번호 필드에 삽입된다. (0부터 시작)
- 확인 응답 번호
    - 호스트 B로부터 도착한 각 세그먼트는 B로부터 A로 들어온 데이터에 대한 순서 번호를 갖는다.
    - 호스트 A가 자신의 세그먼트에 삽입하는 확인응답 번호는 호스트 A가 호스트 B로부터 기대하는 다음 바이트의 순서 번호다.
    - TCP는 스트림에서 첫 번째 잃어버린 바이트까지의 바이트들까지만 확인응답하기 때문에,
    TCP는 누적 확인응답(cumulative acknowledgment)을 제공한다고 한다.

TCP RFC는 TCP 연결에서 순서가 바뀐 세그먼트를 수신할 때 호스트가 어떤 행동을 취해야 하는지에 대한 어떤 규칙도 부여하지 않았고, TCP 구현 개발자에게 맡기고 있다.

- 수신자가 순서가 바뀐 세그먼트를 즉시 버린다.
- 수신자는 순서가 바뀐 데이터를 보유하고, 빈 공간에 잃어버린 데이터를 채우기 위해 기다린다.

후자가 네트워크 대역폭 관점에서는 효율적이며, 실제에서도 취하는 방법이다.